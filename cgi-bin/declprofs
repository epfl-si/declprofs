#!/usr/bin/perl
#
##############################################################################
#
# Author:       Ion CIONCA (Ion.Cionca@epfl.ch) - 2017
#
#########################################################################
#####
#
#

use strict;

use lib '/opt/declprofs/lib/perl';
use utf8;

use Cadi::CadiDB;
use Cadi::Persons;
use Cadi::Accreds;
use Tequila::Client;
use Accred::Roles;
use Data::Dumper;
use Carp;

use HTML::Template;
use CGI;
use Net::LDAPS;
use Mail::Sendmail;
use Date::Calc;
use Encode qw(encode);
use POSIX qw(strftime);
use Tie::IxHash;

#	- get access params
use vars qw($roots $exclude_scipers $add_scipers $test_email $cc_email
            $FORCEPREVYEAR $rollover_date);
require '/usr/local/etc/access_params';  # Populates the variables above

use vars qw($pi $qs $us $me $key $msg $lang $ldap
			$tmpldir $dbh $query $year $REGEX_SCIPER $login_as
			$Persons $authtoken $MAX_SESS_DURATION $AP_email $URL
			$INACT $PENDING $SENT $args $err_msgs $AP_URL $LASTDATE $currentdate
			$PROC $MAX_DELAY $Roles
			$SESSDIR $Accreds $allRemarks
			$ROLE_RESPIT $ROLE_ADMINIT $MINPROFACCRED);

#	- accred
$ROLE_RESPIT	= 19;
$ROLE_ADMINIT	= 20;

$tmpldir 				= '/app/tmpl/';

$lang 					= 'en';
$me 						= $ENV {SCRIPT_NAME};
$us							= $ENV {SERVER_NAME};
$qs 						= $ENV {QUERY_STRING};
$pi 						= $ENV {PATH_INFO};
$URL						= 'https://'.$us.$me;
$REGEX_SCIPER 	= '^[1-9]\d{5}$';	#	
$MINPROFACCRED	= 30; #	- min prof accred (days)

$AP_URL					= "https://professeurs.epfl.ch/page-26444-en.html";
$SESSDIR				= '/app/sessions/';

#	- record status
$INACT					= 0;	#	- replaced by more recent
$PENDING				= 1;	#	- current
$SENT						= 2;	#	- submitted
$MAX_SESS_DURATION	= 3000;		#	- session token valid for 3000sec

$err_msgs = {
	noaccess => qq{This service is for EPFL professors only. <br>Please contact the <a href="$AP_URL">Faculty Affairs</a> for more information},
	noVPNaccess => qq{This service is available only for EPFL intranet. <br>Please contact the <a href="$AP_URL">Faculty Affairs</a> for more information},
};

$CGI::POST_MAX 	= 1024 * 1000; 
$query 		   		= CGI->new();

escapeParams();

foreach my $item ( split /\//, $pi ) {
	next unless $item;
	if ($item =~ /^([a-h\d\:]*)$/) {
		$authtoken = $1;
		next;
	}
  if 	  ($item =~  /^login_as=([1-9]\d{5})$/) {
  	$login_as = $1;
  	next;
	}
	$PROC = $item;
}

$ldap   = Net::LDAPS->new('ldap.epfl.ch')    or error ("failed to connect to LDAPS : $!");

$dbh = new Cadi::CadiDB (
  dbname => 'declprofs',
   trace => 1,
  utf8 => 1
) unless $dbh;
error ("FATAL DB ACCESS") unless $dbh;

$Persons = new Cadi::Persons (
      caller => '104782',
        root => '104782',
    language => 'en',
        utf8 => 1,
);

$Accreds = new Cadi::Accreds (
      caller => '104782',
        root => '104782',
    language => 'en',
        utf8 => 1,
);

$Roles = new Accred::Roles ();

my $_tequila_client;
sub tequila_client {
  if (! $_tequila_client) {
    $_tequila_client = new Tequila::Client (
	  service    => 'professors activities',
	  request    => [ 'name','firstname','uniqueid', 'email'],
	  identities => 'any',
	  urlaccess  => "https://$ENV{SERVER_NAME}$ENV{REQUEST_URI}?$ENV{QUERY_STRING}",
    );
    $_tequila_client->init ();
  }

  $_tequila_client->setlang ($lang);
  $_tequila_client->setclientarg ( 'forcelogin', 1 ) ;
  $_tequila_client->setsessionsdir ($SESSDIR);

  my $AUTHSTRENGTH 	= 2;
  if ($_tequila_client->{attrs}->{authstrength} ne $AUTHSTRENGTH) {
	  $_tequila_client->authstrength ($AUTHSTRENGTH);
  }

  return $_tequila_client;
}


package User;   #############################################################

sub authenticate {
  my ($class, $impersonate) = @_;

  my $tequila = main::tequila_client();
  $tequila->authenticate ();

  my $authenticating = bless {
    sciper => $tequila->{attrs}->{uniqueid},
    lastname => $tequila->{attrs}->{name},
    firstname => $tequila->{attrs}->{firstname},
    email => $tequila->{attrs}->{email}
  }, $class;

  if ( $impersonate && $authenticating->is_root) {
    my $impersonated = $class->by_sciper($impersonate);
    warn "impersonate : $impersonated->{sciper}, $impersonated->{firstname}, $impersonated->{lastname}\n";
    return $impersonated;
  } else {
    warn "authenticate : $authenticating->{sciper}, $authenticating->{firstname}, $authenticating->{lastname}\n";
  }

  return $authenticating;
}

sub is_root {
  my ($self) = @_;
  return $main::roots->{$self->{sciper}};
}

sub by_sciper {
	my ($class, $sciper) = @_;

	return unless $sciper;
	main::error ("malformed sciper") unless $sciper =~ m/$main::REGEX_SCIPER/;

  my $pers = $main::Persons->getPerson ($sciper);
	return bless {
			sciper		=> $sciper,
			lastname  => $pers->{name},
			firstname => $pers->{firstname},
			email  		=> $pers->{email},	  	
	  }, $class;
}

sub by_scipers {
  my ($class, @scipers) = @_;
  my $persData = $main::Persons->getManyPersonsInfos(@scipers);
  map {
    bless {
      sciper => $_,
      %{$persData->{$_}}
    },
  } (keys %$persData);
}

our %_reminders_by_year;

sub _get_reminders {
  my ($self, $yeartodo) = @_;
  return unless $yeartodo;

  if (my $cached = $_reminders_by_year{$yeartodo}) { return $cached; }

  my $sql = qq{select * from reminders where year=?};
  my $sth = $main::dbh->prepare ($sql);
  main::error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $sth;
  my  $rv = $sth->execute (($yeartodo));
  main::error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $rv;
	my $reminders = {};
  while (my $entry = $sth->fetchrow_hashref) {
    $reminders->{$entry->{persid}} = $entry;
  }
  return $_reminders_by_year{$yeartodo} = $reminders;
}

sub get_reminder {
  my ($self, $yeartodo) = @_;
  return $self->_get_reminders($yeartodo)->{$self->{sciper}};
}

sub get_reminder_next_delay {
  my ($self, $yeartodo) = @_;
  my $reminder = $self->get_reminder($yeartodo);
  return $reminder && $reminder->{nxtdelay};
}

sub get_reminder_date {
  my ($self, $yeartodo) = @_;
  my $reminder = $self->get_reminder($yeartodo);
  return $reminder && $reminder->{reminddate};
}

sub is_prof {
  my $sciper = shift->{sciper};
  Profs->all->is_prof($sciper) || grep { $_ eq $sciper } (split m/,/, $main::add_scipers);
}

sub is_root {
  return $main::roots->{shift->{sciper}};
}

package Profs;   #############################################################

sub all { Profs->by_year() }

our %_instances;
sub by_year {
  my ($class, $yeartodo) = @_;

  if (! $_instances{$yeartodo}) {
    my $accreds = {};
    my $unitMap = $class->_do_load($yeartodo);
    foreach my $sciper (keys %$unitMap) {
      $accreds->{$sciper} = $unitMap->{$sciper};
    }
    $_instances{$yeartodo} = bless { year => $yeartodo, accreds => $accreds }, $class;
  }
  return $_instances{$yeartodo};
}

sub as_users {
  User->by_scipers(keys %{shift->{accreds}})
}

sub is_prof {
  my ($class, $sciper) = @_;
  return exists $class->all()->{accreds}->{$sciper};
}

sub _do_load {
  my ($class, $yeartodo) = @_;
  my $profsAccreds = {};
  my $sql = qq{select distinct persid, unitid, ordre, debval, finval from accreds where classid=5};
  if ($yeartodo) {
    $sql .= qq{ and
  				((debval >= '$yeartodo-01-01' and debval < '$yeartodo-12-31') or
  				 (debval <  '$yeartodo-01-01' and (finval is null or finval > '$yeartodo-12-31')) or
  				 (finval >  '$yeartodo-01-01' and finval <= '$yeartodo-12-31')
  				)};
  }
  $sql .= qq{  order by persid, ordre };

  my $sth = $class->dbaccrh->prepare ($sql);
  main::error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $sth;
  my  $rv = $sth->execute ();
  main::error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $rv;
  my $profsAccreds;
  while (my $entry = $sth->fetchrow_hashref) {
 		next if $main::exclude_scipers =~ /$entry->{persid}/;
  	if ( $entry->{finval} ) {
  		my ($Dd,$Dh,$Dm,$Ds) = _getAccredDuration ($entry, $yeartodo);
  		next if $Dd < 30;
 warn "$entry->{persid}: $entry->{debval}:$entry->{finval} :  ($Dd,$Dh,$Dm,$Ds)\n" if $main::exclude_scipers =~ /$entry->{persid}/;
  	}
    $profsAccreds->{$entry->{persid}} = $entry->{unitid} unless defined $profsAccreds->{$entry->{persid}} ;
  }
  
  #	- handle exceptions
  my $sql = qq{select distinct persid, unitid, ordre, debval, finval from accreds where 
  				((debval >= '$yeartodo-01-01' and debval < '$yeartodo-12-31') or
  				 (debval <  '$yeartodo-01-01' and (finval is null or finval > '$yeartodo-12-31')) or
  				 (finval >  '$yeartodo-01-01' and finval <= '$yeartodo-12-31')
  				)};
  	 $sql .= qq{ and persid in ($main::add_scipers)} if $main::add_scipers;
  	 $sql .= qq{ order by persid};
  my $sth = $class->dbaccrh->prepare ($sql);
  main::error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $sth;
  my  $rv = $sth->execute ();
  main::error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $rv;
  while (my $entry = $sth->fetchrow_hashref) {
  	if ( $entry->{finval} ) {
  		my ($Dd,$Dh,$Dm,$Ds) = _getAccredDuration ($entry, $yeartodo);
  		next if $Dd < $main::MINPROFACCRED;
  	}
    $profsAccreds->{$entry->{persid}} = $entry->{unitid} unless defined $profsAccreds->{$entry->{persid}} ;
  }
 
  return $profsAccreds;
}

sub _getAccredDuration {
	my ($entry, $yeartodo) = @_;

	if ($yeartodo) {
		$entry->{debval} = "$yeartodo-01-01 00:00:00" if $entry->{debval} lt "$yeartodo-01-01 00:00:00" ;
	}
	my ($date1, $time1) = split / /, $entry->{debval};
	$date1 =~ s/\-0/-/g; $time1 =~ s/\:0/:/g;
	my ($yy1, $mm1, $dd1) = split /-/, $date1; my ($hh1, $min1, $sec1) = split /-/, $time1;
	my ($date2, $time2) = split / /, $entry->{finval};
	$date2 =~ s/\-0/-/g; $time2 =~ s/\:0/:/g;
	my ($yy2, $mm2, $dd2) = split /-/, $date2; my ($hh2, $min2, $sec2) = split /-/, $time2;

	return Date::Calc::Delta_DHMS ( 
		$yy1,$mm1,$dd1,$hh1,$min1,$sec1,
		$yy2,$mm2,$dd2,$hh2,$min2,$sec2
	);
}

sub scipers {
  my ($self) = @_;
  return keys %{$self->{accreds}};
}

sub hierarchy {
  my ($self, $sciper) = @_;
	my $accreds = $self->{accreds} ;

  if (! $self->{unites}) {
	my %unites = map { $accreds->{$_}  => 1 } keys %$accreds;
	my $unitids= join ",", keys %unites;

	my $sql = qq{select id_unite, hierarchie from dinfo.unites1 where id_unite in ($unitids)};
	my $sth = $self->dbaccrh->prepare ($sql);
	main::error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $sth;
	my  $rv = $sth->execute ();
	main::error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $rv;
	my $units;
	while (my $entry = $sth->fetchrow_hashref) {
	  $units->{$entry->{id_unite}} = substr ($entry->{hierarchie}, 5 );
	}
	$self->{unites} = $units;
  }

  return $self->{unites}->{$self->{accreds}->{$sciper}};
}

my $_dbaccrh;
sub dbaccrh {
  my ($class) = @_;
  if (! $_dbaccrh) {
    $_dbaccrh = new Cadi::CadiDB (
  dbname => 'accred',
   trace => 1,
	 utf8  => 1,
);
main::error ("FATAL DB ACCESS") unless $_dbaccrh;
  }
  return $_dbaccrh;
}


package PDFDecl;   ##########################################################

use PDF::API2;
use File::Temp qw(tempfile);
use List::Util qw(min);
use File::Slurp;

my @pdf_textes = (
 qq|According to the « Directive concerning the management of conflicts of interest within the context of activities or public duties engaged in outside the working sphere » dated December 1st, 2005 (LEX 4.1.1), professors shall disclose outside activities at regular intervals, whenever a new activity is taken up or in the event of any change.|,
 qq||,
 qq|Activities which have to be included in the disclosure are described at articles 1.a, 7 and 8 of LEX 4.1.1. Data will be filed and treated confidentially, subject to the Freedom of Information Act (FoIA, RS 152.3).|,
 qq||,
 qq|With my submission, I have certified that this list of activities is complete and accurate and declare not to have devoted more than the equivalent of 1 day per week to them.|,
     );


use constant mm 				=> 25.4 / 72;
use constant in 				=> 1 / 72;
use constant pt 				=> 1;
use constant std_lead 	=> 12/pt;
use constant small_lead => 10/pt;

use constant epfl_logo	 	=> '/usr/local/apache2/htdocs/images/epfl_logo.png';
use constant text_std_width	  => 260/mm;
use constant margin_bottom				=> 25/mm;

use constant margin_left				=> 20/mm;
use constant in_table_margin_top		=> 5/mm;

tie (our %prof_act_cols, "Tie::IxHash",
  activity => {
    title => 'Type and area of activity (including dual professorships)',
    x => 32/mm,
    w => 40/mm,
  },
  principal => {
    title => 'Name and address of principal (or institution)',
    x => 100/mm,
    w => 60/mm,
  },
  dateFrom => {
    title => 'Start date',
    x => 190/mm,
    w => 40/mm,
  },
  dateTo => {
    title => 'End date',
    x => 230/mm,
    w => 40/mm,
  }
);


sub new {
  my $cls = shift;
  my (undef, $tempfile) = tempfile(SUFFIX => ".pdf");
  my $self = bless {
    pdf_file => $tempfile,
    @_
  };

  $self->{pdf} = PDF::API2->new( -file => $self->{pdf_file} ) || error ("Unable to create PDF : $self->{pdf_file}");

  $self->next_page();
  return $self;
}

sub next_page () {
  my ($self) = @_;
  if ($self->{page_nb}) {
    $self->{page_nb}++;
  } else {
    $self->{page_nb} = 1;
  }
  $self->{page} = $self->{pdf}->page;
  $self->{page}->mediabox(842, 595);

  $self->{page_text} = $self->{page}->text;
  $self->{gfx} = $self->{page}->gfx;
}

sub page { shift->{page} }
sub text { shift->{page_text} }
sub gfx { shift->{gfx} }

sub set_font {
  my ($self, $weight, $size) = @_;

  my %verdana_weight_suffix = (
    Bold => ",Bold",
    Roman => "",
    Italic => ",Italic"
   );
  defined(my $weight_suffix = $verdana_weight_suffix{$weight}) or
    die "Unknown weight: $weight";

  $self->text->font($self->{pdf}->corefont("Verdana,$weight_suffix"), $size);
}

sub make {
  my ($cls, $details) = @_;

  my $prof_act = delete $details->{prof_act} or die "make(): prof_act missing";
  my $self = $cls->new(%$details);

  my $ypos = $self->put_header();
  $ypos = $self->put_description ($ypos);
  $ypos = $self->put_identity ($ypos);
  $self->put_prof_act($ypos, $prof_act);

  #	-- FOOTER
  $self->set_font('Bold', 9/pt);
  $self->text->fillcolor('red');
  my $submitted = $prof_act->{(keys %$prof_act)[0]}->{ts};
  $submitted = $details->{yeartodo} if (! $submitted);
  $self->text_block(
    qq{Date:  $submitted},
    -y        => 20/mm,
    -h				=> 20/mm,
   );

		#	- DONE		
		$self->{pdf}->save;
		$self->{pdf}->end;

  my $bytes = File::Slurp::read_file($self->{pdf_file}, { binmode => ":bytes" });
  die "Empty PDF!" unless length($bytes);
  return $bytes;
}

sub put_horizontal_line {
  my ($self, $ypos, %opts) = @_;

  $opts{max_x} = 280/mm if (! $opts{max_x});

  $self->gfx->linedash( );
  $self->gfx->move(  margin_left, $ypos );
  $self->gfx->line( $opts{max_x}, $ypos );
  $self->gfx->stroke if ($opts{stroke});
}

sub put_prof_act_running_header {
  my ($self, $ypos) = @_;

  $ypos -= 5/mm;
  $self->put_horizontal_line($ypos);

  my $h = 20/mm;

  $ypos -= 7/mm;
  $self->set_font('Roman', 9/pt );
  $ypos = min(map {
    my $k = $_;
    my $col = $prof_act_cols{$k};

    $self->text_block(
			$col->{title},
			-x        => $col->{x},
			-y        => $ypos,
			-h        => $h,
			-w        => $col->{w},
                        -align    => 'left'
		),

  } (keys %prof_act_cols));

  $self->put_horizontal_line($ypos, stroke => 1);

  return $ypos - in_table_margin_top;
}

sub put_prof_act {
  my ($self, $ypos, $prof_act) = @_;
  $ypos = $self->put_prof_act_running_header ($ypos);

	#	- LOOP ON ITEMS
	my $submitted;
	foreach my $index (sort { $a <=> $b } keys %$prof_act) {
		next unless $prof_act->{$index}->{status} eq '2';
		$submitted = $prof_act->{$index}->{ts};
		
		if ( $ypos < margin_bottom ) {
			$self->next_page();
			$ypos = $self->put_header();
			$ypos = $self->put_prof_act_running_header ($ypos );
		}

                my $h = 20/mm;

		$self->text_block(
				$index,
				-x        => 20/mm,
				-y        => $ypos -7/pt,
				-h        => $h,
                                -w        => 20/mm,
			);
		$ypos = min(map {
                  my $k = $_;
                  my $col = $prof_act_cols{$k};
                  $self->text_block(
				$prof_act->{$index}->{$k},
				-x        => $col->{x},
				-y        => $ypos -7/pt,
				-h	  => $h,
				-w        => $col->{w},
			);
                } (keys %prof_act_cols));

		$ypos -= 7/mm;
                $self->put_horizontal_line($ypos, stroke => 1);

		$ypos -= in_table_margin_top;

	}
}

sub put_identity {
	my ($self, $ypos) = @_;
	   $ypos -= 7/mm;

	$self->set_font('Bold', 9/pt );
	$self->{page_text}->fillcolor('red');
	$self->text_block(
			"Full Name:  $self->{user}->{firstname} $self->{user}->{lastname}",
			-y        => $ypos,
			-h				=> 20/mm,
		);
	$self->text_block(
			"EPFL School / College:   $self->{hierarchie}",
			-x        => 180/mm,
			-y        => $ypos,
			-h				=> 20/mm,
		);

		#	- certification line
		$self->{page_text}->fillcolor('black');
		return $self->text_block(
				$pdf_textes[5],
				-y        => $ypos - 7/mm,
				-h				=> 20/mm,
			);
}

sub put_description {
	my ($self, $ypos) = @_;
        my @pdf_txts = @pdf_textes;
	do {
          s/YEARNEXT/$self->{yeartodo} + 1/ge;
          s/YEARTODO/$self->{yeartodo}/g
        } for @pdf_txts;

	#	- DESCRIPTION
	$self->set_font('Roman', 9.5/pt);
	$ypos = $self->text_block(
			$pdf_txts[0],
			-y        => $ypos - 20/pt,
			-h				=> 20/mm,
	);
	$ypos = $self->text_block(
			$pdf_txts[1],
			-y        => $ypos - 7/pt,
			-h				=> 25/mm,
			-lead     => small_lead,
	);
	$ypos = $self->text_block(
			$pdf_txts[2],
			-y        => $ypos - 7/pt,
			-h				=> 25/mm,
			-lead     => small_lead,
	);
	$ypos = $self->text_block(
			$pdf_txts[3],
			-y        => $ypos - 7/pt,
			-h				=> 25/mm,
			-lead     => small_lead,
	);
	$ypos = $self->text_block(
			$pdf_txts[4],
			-y        => $ypos - 7/pt,
			-h				=> 20/mm,
		);

	return $ypos;
}

sub put_header {
	my ($self) = @_;

        $self->set_font("Bold", 9.5/pt );
	$self->{page_text}->fillcolor('black');

	$self->text_block(
			'CONFIDENTIAL',
			-y        => 198/mm,
			-h        => 110/mm - 7/pt,
		);

	my $logo_file = do { no utf8::all; $self->{pdf}->image_png(epfl_logo); };
	$self->gfx->image( $logo_file, 229/mm, 188/mm, 50/mm, 14/mm );

        $self->put_horizontal_line(195/mm, max_x => 215/mm, stroke => 1);

	#	- HEADER
	$self->set_font('Bold', 10/pt );
	my $ypos = $self->text_block(
			'Activities engaged in outside of EPFL',
			-x        => 100/mm,
			-y        => 175/mm,
			-h        => 10/mm,
		);

	$ypos = $self->text_block(
			'Disclosure form for professors  - '.$self->{yeartodo},
			-x        => 100/mm,
			-y        => $ypos - 12/pt,
			-h        => 10/mm,
		);

	#	-- PAGE NB
	$self->set_font('Roman', 8/pt );
	$self->text_block(
			qq{Page $self->{page_nb}},
			-y        => 10/mm,
		);
		
		return $ypos;
}

#_______________
sub text_block {
#
# text_block() is © Rick Measham, 2004-2007. The latest version can be found in the tutorial located at http://rick.measham.id.au/pdf-api2/
#
     my $self = shift;
     my $text        = shift;
     my %arg 				 = @_;
     $arg{-lead}  ||= std_lead;
     $arg{-w}     ||= text_std_width;
     $arg{-align} ||= "justify";
     $arg{-x}     ||= margin_left;

     my $text_object = $self->{page_text};

     # Get the text in paragraphs
     my @paragraphs = split( /\n/, $text );
     # calculate width of all words
     my $space_width = $text_object->advancewidth(' ');

     my @words = split( /\s+/, $text );
     my %width = ();
     foreach (@words) {
         next if exists $width{$_};
         $width{$_} = $text_object->advancewidth($_);
     }

     my $ypos 				 	 = $arg{'-y'};
     my @paragraph 			 = split( / /, shift(@paragraphs) );
     my $first_line      = 1;
     my $first_paragraph = 1;

     # while we can add another line
     while ( $ypos >= $arg{'-y'} - $arg{'-h'} + $arg{'-lead'} ) {

         unless (@paragraph) {
             last unless scalar @paragraphs;
             @paragraph = split( / /, shift(@paragraphs) );
             $ypos -= $arg{'-parspace'} if $arg{'-parspace'};
             last unless $ypos >= $arg{'-y'} - $arg{'-h'};

             $first_line      = 1;
             $first_paragraph = 0;
         }

         my $xpos = $arg{'-x'};

         # while there's room on the line, add another word
         my @line = ();

         my $line_width = 0;
         if ( $first_line && exists $arg{'-hang'} ) {

             my $hang_width = $text_object->advancewidth( $arg{'-hang'} );

             $text_object->translate( $xpos, $ypos );
             $text_object->text( $arg{'-hang'} );

             $xpos       += $hang_width;
             $line_width += $hang_width;
             $arg{'-indent'} += $hang_width if $first_paragraph;

         }
         elsif ( $first_line && exists $arg{'-flindent'} ) {

             $xpos       += $arg{'-flindent'};
             $line_width += $arg{'-flindent'};

         }
         elsif ( $first_paragraph && exists $arg{'-fpindent'} ) {

             $xpos       += $arg{'-fpindent'};
             $line_width += $arg{'-fpindent'};

         }
         elsif ( exists $arg{'-indent'} ) {

             $xpos       += $arg{'-indent'};
             $line_width += $arg{'-indent'};

         }

         while ( @paragraph
             and $line_width + ( scalar(@line) * $space_width ) +
             $width{ $paragraph[0] } < $arg{'-w'} )
         {

             $line_width += $width{ $paragraph[0] };
             push( @line, shift(@paragraph) );

         }

         # calculate the space width
         my ( $wordspace, $align );
         if ( $arg{'-align'} eq 'fulljustify'
             or ( $arg{'-align'} eq 'justify' and @paragraph ) )
         {

             if ( scalar(@line) == 1 ) {
                 @line = split( //, $line[0] );

             }
             $wordspace = ( $arg{'-w'} - $line_width ) / ( scalar(@line) - 1 );
             $align 		= 'justify';
         }
         else {
             $align = ( $arg{'-align'} eq 'justify' ) ? 'left' : $arg{'-align'};
             $wordspace = $space_width;
         }
         $line_width += $wordspace * ( scalar(@line) - 1 );
         if ( $align eq 'justify' ) {
             foreach my $word (@line) {

                 $text_object->translate( $xpos, $ypos );
                 $text_object->text($word);

                 $xpos += ( $width{$word} + $wordspace ) if (@line);

             }
         }
         else {

             # calculate the left hand position of the line
             if ( $align eq 'right' ) {
                 $xpos += $arg{'-w'} - $line_width;

             }
             elsif ( $align eq 'center' ) {
                 $xpos += ( $arg{'-w'} / 2 ) - ( $line_width / 2 );

             }

             # render the line
             $text_object->translate( $xpos, $ypos );

             $text_object->text( join( ' ', @line ) );

         }
         $ypos -= $arg{'-lead'};
         $first_line = 0;

     }

     return $ypos
}


package main;   #############################################################

use List::Util qw(max);

my ($sec,$min,$hour,$mday,$mon,$yr,$wday,$yday,$isdst) = localtime(time);
$mon++;
$year 				= $yr + 1900;

#	----- SIMULATION --
#$year = '2019';
#$mon	= 4;
#	-----

$currentdate 	= sprintf "%04d-%02d-%02d", $year, $mon, $mday;
$MAX_DELAY		= 14;		#	- next decl delay, days

our $CurrentUser = User->authenticate($login_as);
if (! $CurrentUser) {
  error("User unknown.");
  exit;
}

if ($FORCEPREVYEAR) {
  $LASTDATE			= $currentdate;
} elsif ((! $CurrentUser->is_root()) &&
         (my $next_delay = $CurrentUser->get_reminder_next_delay($year - 1))) {
  $LASTDATE = $next_delay;
} else {
  $LASTDATE			= "${year}-${rollover_date}";
}

my $yeartodo 		= $currentdate le $LASTDATE ? $year-1 : $year;

$allRemarks		= getAllRemarks();

my $limit_year = $yeartodo eq $year ? $year + 1 : $yeartodo;

  if 	  ($PROC eq 'save') {
  	save   ();
  } elsif ($PROC eq 'search') {
  	search   ();
  } elsif ($PROC eq 'list') {
  	list   ();
  } elsif ($PROC eq 'missing') {
  	missing   ();
  } elsif ($PROC eq 'clone') {
  	clone   ();
  } elsif ($PROC eq 'extract') {
  	extract   ();
  } elsif ($PROC eq 'history') {
  	history   ();
  } elsif ($PROC eq 'remarks') {
  	remarks   ();
  } elsif ($PROC eq 'pdf') {
  	pdf   ();
  }

  if ( $CurrentUser->is_root ) {
	  list   ($yeartodo);
	} else {
		main ();
	}
exit;

#_________________
sub main {

  my $template;
  if 	  ( $CurrentUser->is_root ) {
		$template = initTempl('profsact_root_main.tmpl');
  } elsif ( $CurrentUser->is_prof ) {
		my $scipertodo 	= $args->{'scipertodo'} ? $args->{'scipertodo'} : $CurrentUser->{sciper};
		my $yeartodo   	= $args->{'yeartodo'}   ? $args->{'yeartodo'} : $yeartodo;
		$template 	 		= initTempl('profsact_main.tmpl');
		$template->param(sNomToDo	 	 => $CurrentUser->{lastname});
		$template->param(sPrenomToDo => $CurrentUser->{firstname});
		$template->param(sYearsLoop	 => [getProfActDataLoop ($scipertodo)]);

  } else {
  	error ("$err_msgs->{noaccess}") ;
  }
  
	$template->param(sNotif 	=> $args->{submit});
	$template->param(sPathMe 	=> $me);
  $template->param(sMsg 		=> $msg);
  binmode(STDOUT, ":utf8");
  print "Content-Type: text/html; charset=UTF-8\n\n", $template->output;
  exit;
}

#_________________
sub getProfActDataLoop {
	my ($scipertodo) = @_;
	return unless $scipertodo;
	
	my $yeartodo 			= $args->{yeartodo} ? $args->{yeartodo} : $yeartodo;
	my $profActByYear = getAllProfAct ($scipertodo);

	my @years_loop; my $yeartodo_done;
	foreach my $crtyear ( sort { $a <=> $b } keys %$profActByYear) {
		next if $args->{yeartodo} and $args->{yeartodo} ne $crtyear;
		my $prof_act = $profActByYear->{$crtyear};
		my @year_act; my $submitted; my $donebyroot;

		foreach my $index (sort { $a <=> $b } keys %$prof_act) {
			push @year_act, { 
				year		 	=> $crtyear, 
				scipertodo=> $scipertodo,
				crt_year 	=> $year, 
				activity 	=> $prof_act->{$index}->{activity}, 
                                dateFrom        => $prof_act->{$index}->{dateFrom},
                                dateTo          => $prof_act->{$index}->{dateTo},
				principal       => $prof_act->{$index}->{principal},
				modYear 	=> yearIsModifiable($crtyear),
				isCrtYear => $crtyear eq $year,
				sPathMe 	=> $me, 
				index 		=> $index, 
			} ;
			$submitted  = $prof_act->{$index}->{ts} if $prof_act->{$index}->{status} eq '2';
			$donebyroot = 1 if $prof_act->{$index}->{doneby} && $prof_act->{$index}->{doneby} ne $scipertodo;
		}

		my $crt_remarks = $CurrentUser->is_root ? $allRemarks->{$crtyear}->{$scipertodo}->{remark} : $allRemarks->{$crtyear}->{$scipertodo}->{prof_remark};

		push @years_loop, {
			year 				=> $crtyear,
			scipertodo 	=> $scipertodo,
			modYear 		=> yearIsModifiable($crtyear),
			isCrtYear 	=> $crtyear eq $year,
			submitted 	=> $submitted,
			yearAct 		=> \@year_act,
			sPathMe 		=> $me, 
			isroot 			=> $CurrentUser->is_root, 
			donebyroot	=> $donebyroot, 
			crt_remarks	=> $crt_remarks, 
			remarks			=> $allRemarks->{$crtyear}->{$scipertodo}->{remark}, 
			prof_remarks=> $allRemarks->{$crtyear}->{$scipertodo}->{prof_remark}, 
		};
		$yeartodo_done ||= $crtyear eq $yeartodo;
	}
	
	my $make_empty_year = sub {
		my ($year_new) = @_;
		return {
			year 	  		=> $year_new,
			scipertodo	=> $scipertodo,
			modYear   	=> yearIsModifiable($year_new),
			isYearEmpty	=> 1,
			yearAct	  	=> [{ 
                          modYear  	=> yearIsModifiable($year_new),
                          isCrtYear => $year_new eq $year, activity => '',
			  isYearEmpty	=> 1,
                          principal => '', index => 1, 
                        }],
			isCrtYear 	=> $year_new eq $year,
			sPathMe   	=> $me, 
			isroot 	  	=> $CurrentUser->is_root, 
			crt_remarks	=> ($CurrentUser->is_root ? $allRemarks->{$year_new}->{$scipertodo}->{remark} : $allRemarks->{$year_new}->{$scipertodo}->{prof_remark}),
			remarks			=> $allRemarks->{$year_new}->{$scipertodo}->{remark},
			prof_remarks=> $allRemarks->{$year_new}->{$scipertodo}->{prof_remark},
		};
	};

	unless (@years_loop && $yeartodo_done) {
		push @years_loop, $make_empty_year->($yeartodo);
	}
	
	@years_loop = sort { $b->{year} cmp $a->{year} } @years_loop;

        # Plug any gap in the years, so that the forms show a contiguous (albeit possibly empty)
        # sequence of years:
        for (my $i = 0; $i + 1 < @years_loop; $i++) {
          if ((my $missing_year = $years_loop[$i]{year} - 1) > $years_loop[$i + 1]{year}) {
            splice(@years_loop, $i + 1, 0, $make_empty_year->($missing_year));
          }
        }

        return @years_loop;

}

sub yearIsModifiable {
  my ($year_q) = @_;

  if ($CurrentUser->is_root) {
    return 1 if ($year - 1) <= $year_q;
  } elsif ($currentdate le $LASTDATE) {
    return 1 if ($year-1) eq $year_q;
  } else {
    return 1 if $year eq $year_q;
  }
  return undef;
}

#_________________
sub missing {

  error ('No access to this function') unless $CurrentUser->is_root;
	my $yeartodo = $args->{yeartodo} ;
#warn ">> missing : yeartodo=$yeartodo\n";
  my $submittedActs = getSubmitted($yeartodo);
  my $profs = Profs->by_year($yeartodo);

	my $emails;
  my @profsLoop;
  foreach my $person ( sort { $a->{name}.$a->{firstname} cmp $b->{name}.$b->{firstname} } $profs->as_users )
  {
	my $sciper = $person->{sciper};
	next if $submittedActs->{$sciper};
        my $units 				= $profs->hierarchy($sciper);

  	my $hasremarks = $allRemarks->{$yeartodo}->{$sciper}->{remark} || $allRemarks->{$yeartodo}->{$sciper}->{prof_remark};
  	push @profsLoop, {
			sPathMe 	=> $me, 
  		sciper 		=> $person->{sciper},
  		lastname 	=> $person->{name},
  		firstname => $person->{firstname},
  		email			=> $person->{email},
  		reminddate=> $person->get_reminder_date($yeartodo),
  		nxtdelay	=> $person->get_reminder_next_delay($yeartodo),
  		unit			=> $units,
			hasremarks=> $hasremarks, 
			remarks		=> $allRemarks->{$yeartodo}->{$sciper}->{remark}, 
			prof_remarks=> $allRemarks->{$yeartodo}->{$sciper}->{prof_remark}, 
			year			=> $yeartodo, 
  	};
  	$emails->{$person->{sciper}} = $person->{email};
  }

  my $template = initTempl('profsact_root_missing.tmpl');
	my $recipients ;
  
  my ($limit_yy, $limit_mm, $limit_dd) = Date::Calc::Add_Delta_Days ($year, $mon, $mday, $MAX_DELAY);

  if ( $args->{op} eq 'remind' ) {

		my $scipers;
		my ($dd, $mm, $yy);
		foreach my $param ( keys %$args ) {
				my ($label, $sciper) = split /_/, $param;
				next unless $label eq 'scipertodo';
				next unless $args->{$param};
				$scipers->{$sciper} = 1;
		}
		error ('No selection for this missing') unless scalar keys %$scipers;
		my ($dd, $mm, $yy) = split /\//, $args->{nxtdelay};
									 $dd =~ s/^0//;
									 $mm =~ s/^0//;
		error ('Wrong limit date, use dd/mm/yyyy syntax') unless Date::Calc::check_date ($yy, $mm, $dd);
  	my $nxtdelay = sprintf "%04d-%02d-%02d", $yy, $mm, $dd;
  	my $nxtdelay_txt = Date::Calc::Date_to_Text_Long($yy, $mm, $dd);

		#	- update reminders
		foreach my $prof ( @profsLoop ) {
			my $sciper = $prof->{sciper};
			next unless $sciper && $scipers->{$sciper};
			my $sql;
			if ( $prof->{reminddate} ) {
				$sql = qq{update reminders set nxtdelay=? where year=? and persid=?};
			} else {
				$sql = qq{insert into reminders set nxtdelay=?, year=?, persid=?};
			}
			my $sth = $dbh->prepare ($sql);
			error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $sth;
			my  $rv = $sth->execute (($nxtdelay, $yeartodo, $sciper));
			error ("Unable to execute on database : $dbh->{errmsg}\n") unless $rv;

			my ($year,$month,$day, $hour,$min,$sec) = Date::Calc::Today_and_Now();; 
			$prof->{reminddate} = sprintf "%04d-%02d-%02d %02d:%02d:%02d", $year, $month, $day, $hour, $min, $sec; 
			$prof->{nxtdelay} 	= $nxtdelay; 

			#	- update logs
			write_logs ($sciper, "notify reminder on $nxtdelay");

			my $subj 	 = qq{Professors activities disclosure missing : $yeartodo};
			my $msg 	 = qq{
			Dear Professor $prof->{firstname} $prof->{lastname},<br>
			<br>
			It seems that your annual disclosure of outside activities has not been uploaded by the official March 31<sup>st</sup> deadline.<br>
			<br>
			Please take care of this matter by <b>$nxtdelay_txt</b>, after which we will contact your Dean/Director.<br>
      <br>
			Best regards,<br>
			Faculty Affairs
			};

			sendmail ( $emails->{$sciper}, $subj, $msg );

			($limit_yy, $limit_mm, $limit_dd) = Date::Calc::Add_Delta_Days ($yy, $mm, $dd, $MAX_DELAY);
			
			$recipients->{$emails->{$sciper}} = 1 if $emails->{$sciper};
			
		}
  }

	my $dest = join ",", keys %$recipients;
#	error ('No recipients to notify') unless $dest;

	$template->param(sRecipients => $dest);
  $template->param(profsLoop 	 => \@profsLoop);
  $template->param(sYearToDo 	 => $yeartodo);
  $template->param(sPathMe 	 	 => $me);
  $template->param(sMsg 		 	 => $msg);
  $template->param(sCrtYear	 	 => $yeartodo eq ($year-1));
  $template->param(sLimitDate	 => sprintf "%02d/%02d/%04d", $limit_dd, $limit_mm, $limit_yy);

  binmode(STDOUT, ":utf8");
  print "Content-Type: text/html; charset=UTF-8\n\n", $template->output;
  exit;
}

#_________________
sub list {
	my $yeartodo = shift;

  error ('No access to this function') unless $CurrentUser->is_root;
  $yeartodo = $args->{'yeartodo'} if $args->{'yeartodo'};
  error ('Year todo not specified') unless $yeartodo;
  
#  my $actByProf = getSubmitted($yeartodo);
  my $profs = Profs->by_year($yeartodo);
  my $actByProf 		= getAllAct($yeartodo);
  my $crtyrprofs		= scalar keys %$actByProf;
  my @scipers				= keys %$actByProf;
  my $yearProfIdents= $Persons->getManyPersonsInfos(@scipers);

  my $sent = 0;
  my $notsent = 0;
  my @profsLoop;
  foreach my $sciper ( sort { $yearProfIdents->{$a}->{name}.$yearProfIdents->{$a}->{firstname} cmp $yearProfIdents->{$b}->{name}.$yearProfIdents->{$b}->{firstname} } keys %$yearProfIdents ) 
  {
  	my $person 		= $yearProfIdents->{$sciper};
  	my $submitted = $actByProf->{$sciper}->[0]->{status} eq $SENT ? $actByProf->{$sciper}->[0]->{ts} : '';
  	if ($submitted) {
  		$sent++ ;
  	} else {
	  	$notsent++ ;
  	}
  	my $donebyroot= $actByProf->{$sciper}->[0]->{doneby};
  	push @profsLoop, {
			sPathMe 	=> $me, 
  		sciper 		=> $person->{sciper},
  		lastname 	=> $person->{name},
  		firstname => $person->{firstname},
  		submitted => $submitted,
  		donebyroot=> $donebyroot,
  		yeartodo 	=> $yeartodo,
			remarks		=> $allRemarks->{$yeartodo}->{$person->{sciper}}->{remark}, 
			prof_remarks=> $allRemarks->{$yeartodo}->{$person->{sciper}}->{prof_remark}, 
  	};
  }

	my $allprofs  = scalar $profs->scipers;
  my $missing		= $allprofs - $crtyrprofs;

  my $template = initTempl('profsact_root_list.tmpl');
  $template->param(profsLoop => \@profsLoop);
  $template->param(sYearToDo => $yeartodo);
  $template->param(sPathMe 	 => $me);
  $template->param(sMsg 		 => $msg);
  $template->param(sent			 => $sent);
  $template->param(notsent	 => $notsent);
  $template->param(missing	 => $missing);
  $template->param(sCrtYear	 => $yeartodo eq ($year-1));

  binmode(STDOUT, ":utf8");
  print "Content-Type: text/html; charset=UTF-8\n\n" . $template->output;
  exit;
}

#_________________
sub search {

  error ('No access to this function') unless $CurrentUser->is_root;
  my $search_item = $args->{'search_item'};
  error ('No search key') unless $search_item;
  
  my $users;
  if ( $search_item =~ m/$REGEX_SCIPER/) {
  	my $user = User->by_sciper($search_item);
  	$users->{$search_item} = $user if $user;
  } else {
  	$users = getUsersByName ($search_item);
  }
  
  error ("no results for : $search_item") unless $users;
  
  my @outloop;
  foreach my $sciper ( keys %$users ) {
		next unless $users->{$sciper}->is_prof;
		push @outloop, {
				sPathMe 	=> $me, 
				sciper 		=> $sciper,
				scipertodo=> $sciper,
				lastname 	=> $users->{$sciper}->{lastname},
				firstname => $users->{$sciper}->{firstname},
				email 		=> $users->{$sciper}->{email},
				isprof 		=> 'professor',
		};
  } 

  my $template;
  if (scalar @outloop == 1 ) {	#	- one result
    $template 		 = initTempl('profsact_root_main.tmpl');
    $template->param(scipertodo	 => $outloop[0]->{sciper});
    $template->param(sOutLoop	 	 => \@outloop);
    $template->param(sNomToDo	 	 => $outloop[0]->{lastname});
    $template->param(sPrenomToDo => $outloop[0]->{firstname});
    $template->param(sYearsLoop	 => [getProfActDataLoop ($outloop[0]->{sciper})]);
  } else {
    $template 		 = initTempl('profsact_root_list.tmpl');
    $template->param(sSearch	 	 => $search_item);
    $template->param(sOutLoop	 	 => \@outloop);
  }

  $template->param(sPathMe => $me);
  $template->param(sMsg 	 => $msg);
  
  binmode(STDOUT, ":utf8");
  print "Content-Type: text/html; charset=UTF-8\n\n", $template->output;
  exit;
}

#_________________
sub getAllRemarks {
	my $remarks;
  my $sql = qq{select * from remarks};
  my $sth = $dbh->prepare ($sql);
  error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $sth;
  my  $rv = $sth->execute ();
  error ("Unable to execute database : $dbh->{errmsg}\n") unless $rv;
  while (my $entry = $sth->fetchrow_hashref) {
    $remarks->{$entry->{year}}->{$entry->{persid}} = $entry;
  }
  return $remarks;
	
}

#_________________
sub remarks {

	my $scipertodo = $args->{'scipertodo'} ;
#	error ('No access to this function') unless $CurrentUser->is_root ;
	my $yeartodo 	 = $args->{'yeartodo'} ;
	error ('No access yeartodo') unless $yeartodo ;
	
	my $remarks		  = $args->{'remarks'} ;
	my $remark_type = $CurrentUser->is_root ? 'remark' : 'prof_remark';

#warn "--> remarks :: $scipertodo, $yeartodo :: $remarks	\n";	
	my $sql;
	if ( defined $allRemarks->{$yeartodo}->{$scipertodo} ) {
		$sql = qq{update remarks set $remark_type=?, doneby=? where persid=? and year=? };
	} else {
		$sql = qq{insert into remarks set $remark_type=?, doneby=?, persid=?, year=? };
	}
  my $sth = $dbh->prepare ($sql);
  error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $sth;
  my  $rv = $sth->execute ($remarks, $CurrentUser->{sciper}, $scipertodo, $yeartodo);
  error ("Unable to update database : $dbh->{errmsg}\n") unless $rv;

	write_logs ($scipertodo, "remarks $yeartodo");
	
        binmode(STDOUT, ":utf8");
        print "Content-Type: text/html; charset=UTF-8\n\n";
	print qq{
	<script>
	location.href="$me";
	</script>
	};

}

#_________________
sub history {

	my $scipertodo 	= $args->{'scipertodo'} ? $args->{'scipertodo'} :  $CurrentUser->{sciper};
	error ('No access to this function') unless $CurrentUser->is_root || $CurrentUser->{sciper} eq $scipertodo;
#warn "--> history  for $scipertodo\n";

	my $prof_act  = getProfHistory ($scipertodo);
	my $retHTML = qq{<h3>Activity history</h3>
		<div class="row">
		<div class="col-md-2 box_title grey">Created</div>
		<div class="col-md-1 box_title grey">Order</div>
		<div class="col-md-2 box_title grey">Activity</div>
		<div class="col-md-2 box_title grey">Principal</div>
		<div class="col-md-2 box_title grey">Start</div>
		<div class="col-md-2 box_title grey">End</div>
		<div class="col-md-1 box_title grey">Status</div>
		</div>
	};
	foreach my $item (sort { $b->{ts}.$b->{ordre} cmp $a->{ts}.$a->{ordre} } @$prof_act) {
		my $status = $item->{status} eq '2' 
					? 'submitted' 
					: $item->{status} eq '1' 
					? 'pending'
					: 'replaced';
		$retHTML .= qq{
		<div class="row underlined">
		<div class="col-md-2">$item->{ts}</div>
		<div class="col-md-1">$item->{ordre}</div>
		<div class="col-md-2">$item->{activity}</div>
		<div class="col-md-2">$item->{principal}</div>
		<div class="col-md-2">$item->{dateFrom}</div>
		<div class="col-md-2">$item->{dateTo}</div>
		<div class="col-md-1">$status</div>
		</div>
		};
	}
	$retHTML .= qq{</div>};

        binmode(STDOUT, ":utf8");
	print "Content-Type: text/html; charset=UTF-8\n\n", $retHTML;
	exit;

}

#_________________
sub clone {

	my $UserTodo = $args->{'scipertodo'} ? User->by_sciper($args->{'scipertodo'}) : $CurrentUser;
	error ('No access to this function') unless $UserTodo->is_prof || $UserTodo->is_root;
	my $fromyear = $args->{'fromyear'};
	error ('Source year undefined') unless $fromyear;

	my $profActByYear = getAllProfAct ($UserTodo->{sciper});
	my $crt_act			  = $profActByYear->{$yeartodo};
	my $act_to_clone  = $profActByYear->{$fromyear};
warn(scalar(keys %$act_to_clone) . " activities in " . $fromyear);

	if ($args->{index}) {
		error ('Activity not found') unless defined $act_to_clone->{$args->{index}};
		my $next_order = max(keys %$crt_act) + 1;

		my $sql = qq{insert into profsacts set
				 persid = ?,
					 year = ?,
				 status = ?,
						 ts = now(),
					ordre = ?,
			 activity = ?,
			principal = ?,
                        dateFrom = ?,
                        dateTo = ?,
				 doneby = ?
		};
#		my $doneby = $UserTodo->{sciper} if $scipertodo ne $UserTodo->{sciper} ;
		my $sth 	 = $dbh->prepare ($sql);
		error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $sth;
		my  $rv 	 = $sth->execute ( 
			$UserTodo->{sciper}, 
			$yeartodo, 
			$PENDING, 
			$next_order,
			$act_to_clone->{$args->{index}}->{activity}, 
			$act_to_clone->{$args->{index}}->{principal},
			$act_to_clone->{$args->{index}}->{dateFrom},
			$act_to_clone->{$args->{index}}->{dateTo},
			$UserTodo->{sciper} 
		);
		error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $rv;
	} else {
		putProfAct ($yeartodo, $act_to_clone);
	}

	$me =~ s/\/clone.*$//;
	$me.= qq{/search?search_item=$UserTodo->{sciper}} if $CurrentUser->is_root ;

        binmode(STDOUT, ":utf8");
        print "Content-Type: text/html; charset=UTF-8\n\n";
	print qq{
	<script>
	location.href="$me";
	</script>
	};

	exit;
	
	my $template 	= initTempl('profsact_main.tmpl');
	$template->param(sNomToDo	 	 => $UserTodo->{lastname});
	$template->param(sPrenomToDo => $UserTodo->{firstname});
	$template->param(sYearsLoop	 => [getProfActDataLoop ($UserTodo->{sciper})]);

        binmode(STDOUT, ":utf8");
	print "Content-Type: text/html; charset=UTF-8\n\n", $template->output;
	exit;

}

#_________________
sub extract {

	error ('No access to this function') unless $CurrentUser->is_root;
	my $yeartodo 		= $args->{'yeartodo'};
	my $scipertodo 	= $args->{'scipertodo'};

	my $output = qq{year\tsciper\torder\tactivity\tprincipal\tfrom\tto\n};
	my $file_name;
	my $output;
	my $dataSource;

	if ($yeartodo) {
		error ('Source year undefined') unless $yeartodo;
		my $submittedActs = getSubmitted($yeartodo);

		my $profs = Profs->by_year($yeartodo);
		my @scipers;
		my $allroles;
		if ( $args->{'what'} eq 'missing' ) {
			$file_name  = qq{prof_missing_decl_${yeartodo}.csv};

			$allroles		   		 = $Roles->getRoles( () )  ;
			my $resps 			   = $allroles->{$ROLE_RESPIT};
			my @resps_scipers	 = map { keys %{$resps->{$_}}  } keys %$resps;
			my $admins 				 = $allroles->{$ROLE_ADMINIT};
			my @admins_scipers = map { keys %{$admins->{$_}} } keys %$admins;

			$dataSource = map { $_ => 1 } $profs->scipers;
			@scipers					 = ( keys %$dataSource, @resps_scipers, @admins_scipers );

		} else {
			$dataSource = $submittedActs;
			$file_name  = qq{prof_decl_${yeartodo}.csv};
			@scipers		= keys %$dataSource;
		}
		my %seen;
		@scipers = grep { !$seen{$_}++ } @scipers;

		my $persData= $Persons->getManyPersonsInfos(@scipers);

		$output = $args->{'what'} eq 'missing' 
						? qq{year\tsciper\tname\tfirstname\tunit\trespIT\tadminIT\n} 
						: qq{year\tsciper\tname\tfirstname\tunit\torder\tactivity\tprincipal\tfrom\tto\n};

		foreach my $sciper ( sort { $persData->{$a}->{name}.$persData->{$a}->{firstname} cmp $persData->{$b}->{name}.$persData->{$b}->{firstname} } keys %$dataSource ) {
			my $units 				= Profs->by_year($yeartodo)->hierarchy($sciper);

			if ( $args->{'what'} eq 'missing' ) {
				next if $submittedActs->{$sciper};

				my $unitResps  = $allroles->{$ROLE_RESPIT}->{$profs->scipers};
				my $unitAdmins = $allroles->{$ROLE_ADMINIT}->{$profs->scipers};
				my $resps  = join ",", map { "$persData->{$_}->{name} $persData->{$_}->{firstname}" } keys %$unitResps;
				my $admins = join ",", map { "$persData->{$_}->{name} $persData->{$_}->{firstname}" } keys %$unitAdmins;

				$output .= qq{$yeartodo\t$sciper\t$persData->{$sciper}->{name}\t$persData->{$sciper}->{firstname}\t$units\t$resps\t$admins\n};
				
			} else {
				my $prof_data = $submittedActs->{$sciper};
				foreach my $row ( sort { $a->{ordre} <=> $b->{ordre} } @$prof_data  ) {
					$row->{activity}  =~ s/\t/ /g;
					$row->{principal} =~ s/\t/ /g;
					$row->{activity}  =~ s/\n/ /g;
					$row->{principal} =~ s/\n/ /g;
					$row->{activity}  =~ s/\r/ /g;
					$row->{principal} =~ s/\r/ /g;

					$row->{activity}  =~ s/&amp;/&/g;
					$row->{principal} =~ s/&amp;/&/g;
#					$row->{activity}  = encode('UTF-8', $row->{activity});
#					$row->{principal} = encode('UTF-8', $row->{principal});

					$output .= qq{$yeartodo\t$sciper\t$persData->{$sciper}->{name}\t$persData->{$sciper}->{firstname}\t$units\t$row->{ordre}\t$row->{activity}\t$row->{principal}\t$row->{dateFrom}\t$row->{dateTo}\n};
				}
			}
		}

	} else {
		error ('Professor sciper not defined') unless $scipertodo;
		my $submittedActs = getAllProfAct($scipertodo);

	  $output = qq{year\tsciper\torder\tactivity\tprincipal\tfrom\tto\n};
	
		foreach my $year ( sort { $a <=> $b } keys %$submittedActs ) {
			foreach my $index ( sort { $a <=> $b } keys %{$submittedActs->{$year}} ) {
				$submittedActs->{$year}->{$index}->{activity}  =~ s/\t/ /g;
				$submittedActs->{$year}->{$index}->{principal} =~ s/\t/ /g;
				$submittedActs->{$year}->{$index}->{activity}  =~ s/\n/ /g;
				$submittedActs->{$year}->{$index}->{principal} =~ s/\n/ /g;
				$submittedActs->{$year}->{$index}->{activity}  =~ s/\r/ /g;
				$submittedActs->{$year}->{$index}->{principal} =~ s/\r/ /g;

				$submittedActs->{$year}->{$index}->{activity}  =~ s/&amp;/&/g;
				$submittedActs->{$year}->{$index}->{principal} =~ s/&amp;/&/g;
#				$submittedActs->{$year}->{$index}->{activity}  = encode('UTF-8', $submittedActs->{$year}->{$index}->{activity});
#				$submittedActs->{$year}->{$index}->{principal} = encode('UTF-8', $submittedActs->{$year}->{$index}->{principal});

				$output .= qq{$year\t$scipertodo\t$index\t$submittedActs->{$year}->{$index}->{activity}\t$submittedActs->{$year}->{$index}->{principal}\t$submittedActs->{$year}->{$index}->{dateFrom}\t$submittedActs->{$year}->{$index}->{dateTo}\n};
			}
		}
		$file_name = qq{prof_decl_${yeartodo}_${scipertodo}.csv};
	}
	
	print "Content-Type:application/x-download\n";
	print "Content-Disposition:attachment;filename=$file_name\n\n";
	print $output;

	exit;

}

#_________________
sub save {

#	error ('No access to this function') unless $CurrentUser->is_prof;
	my $yeartodo = $args->{year};

  unless ($args->{save_apr_remarks}) {
		my $items;	  
		foreach my $param ( keys %$args ) {
			my ($label, $index) = split /_/, $param;
			next unless $label ;
			$label =~ s/$yeartodo//;
			$items->{$index}->{$label} = $args->{$param};
		}
	
		my $data;
		my $ordre = 1;
		foreach my $index ( sort { $a cmp $b } keys %$items ) {
			next unless $items->{$index}->{activity} ;
			$data->{$ordre}->{activity}  = $items->{$index}->{activity};
			$data->{$ordre}->{principal} = $items->{$index}->{principal};
			$data->{$ordre}->{dateFrom} = $items->{$index}->{dateFrom};
			$data->{$ordre}->{dateTo} = $items->{$index}->{dateTo};
			$ordre++;
		}
		
		putProfAct ($yeartodo, $data);
  }

	my $remarks		  = $args->{'remarks'} ;
	my $remark_type = $CurrentUser->is_root ? 'remark' : 'prof_remark';
	my $doneby			= $CurrentUser->{sciper} if $CurrentUser->is_root; 
	my $sql;
	if ( defined $allRemarks->{$yeartodo}->{$args->{scipertodo}} ) {
		$sql = qq{update remarks set $remark_type=?, doneby=? where persid=? and year=? };
	} else {
		$sql = qq{insert into remarks set $remark_type=?, doneby=?, persid=?, year=? };
	}
  my $sth = $dbh->prepare ($sql);
  error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $sth;
  my  $rv = $sth->execute ($remarks, $doneby, $args->{scipertodo}, $yeartodo);
  error ("Unable to update database : $dbh->{errmsg}\n") unless $rv;
	write_logs ($args->{scipertodo}, "$remark_type $yeartodo");

	$me =~ s/\/save//;
        binmode(STDOUT, ":utf8");
        print "Content-Type: text/html; charset=UTF-8\n\n";
	print qq{
	<script>
	location.href="$me";
	</script>
	};
	exit(0);
}

#_________________
sub getAllYears {

  my $sql = qq{select distinct year from profsacts where status <> ?};
  my $sth = $dbh->prepare ($sql);
  error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $sth;
  my  $rv = $sth->execute ($INACT);
  error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $rv;
  my @years;
  while (my $entry = $sth->fetchrow_hashref) {
    push @years, { year => $entry->{year}, sPathMe => $me, };
  }
  return @years;

}

#_________________
sub getSubmitted {
  my ($yeartodo) = @_;
  error ('year to do not specified') unless $yeartodo;

  my $sql = qq{select * from profsacts where year=? and status = ? };
  my $sth = $dbh->prepare ($sql);
  error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $sth;
  my  $rv = $sth->execute ($yeartodo, $SENT);
  error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $rv;
  my $rows;
  while (my $entry = $sth->fetchrow_hashref) {
    push @{$rows->{$entry->{persid}}}, $entry;
  }
  return $rows;

}
#_________________
sub getAllAct {
  my ($yeartodo) = @_;
  error ('year to do not specified') unless $yeartodo;

  my $sql = qq{select * from profsacts where year=? and status <> '0' order by status desc};
  my $sth = $dbh->prepare ($sql);
  error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $sth;
  my  $rv = $sth->execute ($yeartodo);
  error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $rv;
  my $rows;
  while (my $entry = $sth->fetchrow_hashref) {
    push @{$rows->{$entry->{persid}}}, $entry;
  }
  return $rows;

}

#_________________
sub getAllProfAct {
  my ($scipertodo) = @_;
  error ('person identity not specified') unless $scipertodo;

  my $sql = qq{select * from profsacts where persid=? and status <> ? };
  my $sth = $dbh->prepare ($sql);
  error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $sth;
  my  $rv = $sth->execute ($scipertodo, $INACT);
  error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $rv;
  my $rows;
  while (my $entry = $sth->fetchrow_hashref) {
    my $order = $entry->{ordre};
    $rows->{$entry->{year}}->{$order}->{activity}  = $entry->{activity};
    $rows->{$entry->{year}}->{$order}->{principal} = $entry->{principal};
    $rows->{$entry->{year}}->{$order}->{dateFrom}  = $entry->{dateFrom};
    $rows->{$entry->{year}}->{$order}->{dateTo}    = $entry->{dateTo};
    $rows->{$entry->{year}}->{$order}->{status}    = $entry->{status};
    $rows->{$entry->{year}}->{$order}->{ts}    	   = $entry->{ts};
    $rows->{$entry->{year}}->{$order}->{doneby}    = $entry->{doneby};
  }
  return $rows;

}

#_________________
sub getProfAct {
  my ($scipertodo, $yeartodo) = @_;
#  $type = $PENDING unless $type;
#warn "--> getProfAct : $scipertodo, $yeartodo\n";

  my $sql = qq{select * from profsacts  where persid=? and year=? and status=?  };
  my $sth = $dbh->prepare ($sql);
  error ("Unable to connect to database. Please contact 1234\@epfl.ch\n$sql\n") unless $sth;
  my  $rv = $sth->execute ($scipertodo, $yeartodo, $SENT);
  error ("Unable to execute command to database : $dbh->{errmsg}\n($scipertodo, $yeartodo, $SENT)\n") unless $rv;
  my $rows;
  while (my $entry = $sth->fetchrow_hashref) {
    my $order = $entry->{ordre};
    $rows->{$order} = $entry;
  }
  return $rows;

}

#_________________
sub getProfHistory {
  my ($scipertodo) = @_;
#warn "--> getProfHistory : $scipertodo\n";

  my $sql = qq{select * from profsacts  where persid = ? };
  my $sth = $dbh->prepare ($sql);
  error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $sth;
  my  $rv = $sth->execute ($scipertodo);
  error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $rv;
  my @rows;
  while (my $entry = $sth->fetchrow_hashref) {
#warn "   $entry->{persid} :: $entry->{ts}, $entry->{status} : $entry->{activity}\n";
    push @rows, $entry;
  }
  return \@rows;

}

#_________________
sub putProfAct {
  my ($yeartodo, $data) = @_;
use Data::Dumper; warn(sprintf("putProfAct(%s, %s)", $yeartodo, Dumper($data)));

	my $scipertodo = $CurrentUser->{sciper};
	   $scipertodo = $args->{scipertodo} if $CurrentUser->is_root && $args->{scipertodo};

	#	- all current year act inactive
  my $sql = qq{update profsacts set status=? where persid=? and year=? and status <> ?};
  my $sth = $dbh->prepare ($sql);
  error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $sth;
  my  $rv = $sth->execute ($INACT, $scipertodo, $yeartodo, $INACT);
  error ("Unable to update database : $dbh->{errmsg}\n") unless $rv;

  my $status = $args->{submit} ? '2' : '1';
  my $sql = qq{insert into profsacts set
  		 persid = ?,
         year = ?,
       status = ?,
           ts = now(),
        ordre = ?,
     activity = ?,
    principal = ?,
     dateFrom = ?,
       dateTo = ?,
       doneby = ?
  };
	my $doneby = $CurrentUser->{sciper} if $scipertodo ne $CurrentUser->{sciper} ;
  my $sth 	 = $dbh->prepare ($sql);
  error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $sth;
  my $items  = 0;
  foreach my $row (sort { $a <=> $b } keys %$data) {
    my  $rv = $sth->execute ( $scipertodo, $yeartodo, $status, $row, $data->{$row}->{activity}, $data->{$row}->{principal},
                              $data->{$row}->{dateFrom}, $data->{$row}->{dateTo}, $doneby );
    error ("Unable to connect to database. Please contact 1234\@epfl.ch\n") unless $rv;
    $items++;
  }
  
  if ($args->{submit} && $items == 0) {
    my  $rv = $sth->execute ( $scipertodo, $yeartodo, $status, '1', 'N/A', 'N/A', $doneby );
  }

  my $msg;
  my $date = strftime("%d.%m.%Y", localtime);
  if ( $scipertodo ne $CurrentUser->{sciper} ) {


  	my $user = User->by_sciper($scipertodo);
  	error ("person not found") unless $user;

	  my $subj = "APR modification - annual disclosure of $yeartodo outside activities";
		$msg 		 = qq{
		Dear Professor $user->{firstname} $user->{lastname},<br>
		<br>
		The disclosure of your outside activities, as of $date, has been updated successfully.<br>
		<br>
		Thank you and best regards,<br>
		<br>
		EPFL Faculty Affairs Team
		};

		write_logs ($scipertodo, "APR $yeartodo act update ($items items)");
  	
  	sendmail ( $user->{email}, $subj, $msg );
	} else {

		write_logs ($scipertodo, "$yeartodo act update ($items items)");

		if ( $args->{submit} ) {
			my $subj = "$CurrentUser->{firstname} $CurrentUser->{lastname} annual disclosure of outside activities = ok";
			$msg 		 = qq{
			Dear Professor $CurrentUser->{firstname} $CurrentUser->{lastname},<br>
			<br>
			The disclosure of your outside activities, as of $date, has been updated successfully.<br>
			<br>
			Thank you and best regards,<br>
			<br>
			EPFL Faculty Affairs Team
			};
			sendmail ( $CurrentUser->{email}, $subj, $msg );
			write_logs ($scipertodo, "$yeartodo act submitted ($items items)");
		}

	}
  return 1;
}

#_________________----------
sub initTempl {
  my ($tmpl) = @_;

  my $errMsg;
  my $template_file = $tmpldir.$tmpl;
  unless  (-f $template_file) {
   $errMsg = "template file not found [$template_file]";
   $template_file = "${tmpldir}profsact_def.tmpl";
  }

  my $template = HTML::Template->new(filename => $template_file,
	   strict => 0,
	   cache => 1,
           utf8 => 1,
	   die_on_bad_params => 0) or die "err : $!";
  $template->param(serrMsg 		=> $errMsg);
  $template->param(sPathMe 		=> $me);
  $template->param(sYear 			=> $year);
  $template->param(sYearToDo	=> $yeartodo);
  $template->param(isCrtYear	=> $yeartodo eq $year);
  $template->param(sLimitYear	=> $limit_year);
  my @stat_myself = stat($ENV{SCRIPT_FILENAME});
  $template->param(sBuildTimestamp => $stat_myself[9]);

  my $is_root = $CurrentUser && $CurrentUser->is_root;
  $template->param(isRoot	 		=> $is_root);
  $template->param(yearsLoop 	=> $is_root ? [getAllYears] : []);

  if ($CurrentUser) {
    $template->param(scipertodo	=> $CurrentUser->{sciper});
    $template->param(sNom 			=> $CurrentUser->{lastname});
    $template->param(sPrenom 		=> $CurrentUser->{firstname});
  }
  $template->param(sNxtDelay 	=> $LASTDATE);

#warn "--> initTempl : scipertodo=$CurrentUser->{sciper}\n";

  if ($errMsg) {
    binmode(STDOUT, ":utf8");
     print "Content-Type: text/html; charset=UTF-8\n\n", $template->output;
     exit;
  }

  return $template;
}

#_________________
sub genrandomkey {
  my $len = shift || 16;
  my $rand;
  open (RND, "/dev/urandom") || die "Unable to init random engine : $!";
  binmode(RND);
  if (sysread (RND, $rand, $len) != $len) { die "Unable to read random bytes : $!"; }
  close (RND);
  return $rand;
}

#_________________
sub error {
   my $msg = shift;

   my $template = initTempl('profsact_err.tmpl');
   $template->param(sMsg => $msg);
   binmode(STDOUT, ":utf8");
   print "Content-Type: text/html; charset=UTF-8\n\n", $template->output;
   exit;
}

#___________________
sub escapeParams {

	foreach my $name ( $query->param() ) {
		$args->{$name} =  $query->param($name);
	}
	foreach my $name ( $query->url_param() ) {
		$args->{$name} =  $query->url_param($name);
	}

	foreach my $name ( keys %$args ) {
		my $value = $args->{$name};
		$value =~ s/\\a/a/ig;
		$value =~ s/\\a/a/ig;
		$value =~ s/\\b/b/ig;
		$value =~ s/\\c/c/ig;
		$value =~ s/\\d/d/ig;
		$value =~ s/\\e/e/ig;
		$value =~ s/\\f/f/ig;
		$value =~ s/\\j/j/ig;
		$value =~ s/\\k/k/ig;
		$value =~ s/\\l/l/ig;
		$value =~ s/\\o/o/ig;
		$value =~ s/\\p/p/ig;
		$value =~ s/\\r/r/ig;
		$value =~ s/\\s/s/ig;
		$value =~ s/\\t/t/ig;
		$value =~ s/\\u/u/ig;
		$value =~ s/\\v/v/ig;
		$value =~ s/\\x/x/ig;
		$value =~ s/\\y/y/ig;

		#	- URI decode
		$value =~ s/\+/ /g; $value =~ s/&#([A-Fa-f\d]+);/chr $1/eg;
		
		checkJSExploits ($value);

		#	- escape HTML 
		$value =~ s#&#&amp;#g;
		$value =~ s#<#&lt;#g;
		$value =~ s#>#&gt;#g;
		$value =~ s#"&#&quot;#g;
#		$value =~ s#/#&\#x2F;#g;
#		$value =~ s#'#&\#x27;#g;
#warn "--> escapeParams $name=$value\n";

		if ( $name eq 'scipertodo' ) {
			error ("Illegal value for param : $name=$value\n") unless $value =~ m/$REGEX_SCIPER/ ;
		}
		if ( $name eq 'yeartodo' || $name eq 'fromyear' ) {
			error ("Illegal value for param : $name=$value\n") unless $value =~ m/^2\d\d\d$/ ;
		}

		$args->{$name} = $value;
	}
}

#___________________
sub checkJSExploits {
	my $param = shift;
	return unless $param;

	# - check JS CSS vulnerabilty
	my $exploittxt = qq{content refused, potential malware or illegal keywords found} ;
	my @exploits1 = ('FRAME','OBJECT','META','APPLET','LINK','IFRAME');
	# - check JS events vulnerabilty
	my @exploits2 = (
		'onblur',
		'onchange',
		'onclick',
		'oncopy',
		'oncut',
		'ondblclick',
		'ondrag',
		'ondrop',
		'onerror',
		'onfocus',
		'onkey',
		'onkeypress',
		'onload',
		'onmouse',
		'onpaste',
		'onreset',
		'onresize',
		'onsearch',
		'onselect',
		'onsubmit',
		'onunload',
		'oncontext',
		'oninput',
		'oninvalid',
	);
	my @exploits3 = (
		'script',
		'style',
		'javascript',
		'audio',
		'video',
	);

	$param =~ s/\\a/a/ig;
	$param =~ s/\\a/a/ig;
	$param =~ s/\\b/b/ig;
	$param =~ s/\\c/c/ig;
	$param =~ s/\\d/d/ig;
	$param =~ s/\\e/e/ig;
	$param =~ s/\\f/f/ig;
	$param =~ s/\\j/j/ig;
	$param =~ s/\\k/k/ig;
	$param =~ s/\\l/l/ig;
	$param =~ s/\\o/o/ig;
	$param =~ s/\\p/p/ig;
	$param =~ s/\\r/r/ig;
	$param =~ s/\\s/s/ig;
	$param =~ s/\\t/t/ig;
	$param =~ s/\\u/u/ig;
	$param =~ s/\\v/v/ig;
	$param =~ s/\\x/x/ig;
	$param =~ s/\\y/y/ig;

	#	- URI decode

	$param =~ s/\+/ /g; $param =~ s/&#([A-Fa-f\d]+);/chr $1/eg;
	$param =~ s/\\//g;

	foreach my $exploit (@exploits1) {
		 error ($exploittxt.$exploit) if ($param =~ m#<\s*$exploit[^>]*>#i) ;
	}

	foreach my $exploit (@exploits2) {
		 if ($param =~ /\b$exploit(enter|up|down|over|out|press)?\s?=/i) {
warn " ** ERR JS EXPLOIT 2 : exploit=$exploit\n";		   
				error ($exploittxt);
		 }
	}

	foreach my $exploit (@exploits3) {
		 if ($param =~ m#<\s*$exploit[^>]*>#i) {
warn " ** ERR JS EXPLOIT 3 : exploit=$exploit\n";		   
				error ($exploittxt);
		 }
	}

}

#_________________
sub getUsersByName {
	my ($name) = @_;
	return unless $name;
	
	$name = encode('UTF-8', $name);

  my $persons;
  foreach my $sciper ( $Persons->findPersons ($name) ) {
  	next unless $sciper =~ m/$REGEX_SCIPER/;
  	$persons->{$sciper} = User->by_sciper ($sciper);
  }

  return $persons;

}

#_____________
sub sendmail {
	my ($dest, $subj, $msg) = @_;
	return unless ($msg);

	my $SENDMAIL_CMD = '/usr/sbin/sendmail';

	my $mailTo  		 = $test_email || $dest;
	my $replyTo 		 = 'noreply@epfl.ch';

warn "mailTo : $mailTo\n";
warn "dest : $dest\n";

#return;

	eval {
		open  (MAIL, "| $SENDMAIL_CMD -t -F$replyTo -f$replyTo") or return;
                binmode(MAIL, ":utf8");
		print MAIL qq{To: $mailTo\n};
		print MAIL qq{Cc: $cc_email\n} if $cc_email;
		print MAIL qq{Reply-to: $replyTo
Subject: $subj
Content-type: text/html; charset=utf-8

$msg
		};
		close (MAIL);
	} or do {
		warn "error in mailto [ $dest ] : $@\n"; 
		error("error in mailto [ $dest ] : $@\n");
	};

}

sub dumpit {
  my @things = @_;

  map {
    if (ref($_)) {
      $_ = Data::Dumper->new([$_])->Indent(0)->Dump;
    }
  } @things;

  warn(Carp::longmess(join(" ", @things)));
}


sub pdf {
  my $scipertodo;
  if ($CurrentUser->is_root && $args->{scipertodo}) {
    $scipertodo = $args->{scipertodo};
  } else {
    $scipertodo = $CurrentUser->{sciper};
  }

  my $user 		= User->by_sciper($scipertodo);
  error ("person not found") unless $user;
  my $hierarchie = Profs->by_year($yeartodo)->hierarchy($scipertodo);

    print "Content-Type: application/pdf\n\n";

    my $prof_act   = getProfAct ($scipertodo, $yeartodo);
    dumpit "--> PDFDecl->make : getProfAct -> " => $prof_act;
    print PDFDecl->make (
      { user => $user,
        yeartodo => $yeartodo,
        scipertodo => $scipertodo,
        prof_act => $prof_act,
        hierarchie => $hierarchie
      });
    exit;
}

#	-------------
sub write_logs {
	my ($scipertodo, $descr) = @_;
	return unless $scipertodo && $descr;

  my $sql = qq{insert into logs set
  		 persid = ?,
  		 doneby = ?,
        descr = ?
  };
  my $sth 	 = $dbh->prepare ($sql);
	my  $rv 	 = $sth->execute (($scipertodo, $CurrentUser->{sciper}, $descr));
	error ("Unable to execute on database : $dbh->{errmsg}\n") unless $rv;
	
}

#	-------------
my $createtable = qq{
  create table profsacts (
         year char(4),
        ordre tinyint,
       persid char(6) not null,
       status char(1),
      	   ts datetime,
     activity varchar(256),
    principal varchar(256),
       persid char(6) not null,
        index (persid, year)
  );
};

#CREATE TABLE `profsacts` (
#  `year` char(4) DEFAULT NULL,
#  `ordre` tinyint(4) DEFAULT NULL,
#  `persid` char(6) nOT NULL,
#  `activity` varchar(256) DEFAULT NULL,
#  `principal` varchar(256) DEFAULT NULL,
#  `ts` datetime DEFAULT NULL,
#  `status` char(1) DEFAULT NULL,
#  `doneby` char(6) NOT NULL,
#  KEY `persid` (`persid`,`year`)
#) ENGINE=MyISAM DEFAULT CHARSET=latin1 |
